import{_ as i,c as o,o as t,ag as n}from"./chunks/framework.DPDPlp3K.js";const s="/assets/time_correctness_coefficient.DIN-t8De.png",f=JSON.parse('{"title":"Repetitions","description":"","frontmatter":{},"headers":[],"relativePath":"user-guide/repetition.md","filePath":"user-guide/repetition.md"}'),r={name:"user-guide/repetition.md"};function a(l,e,c,d,u,p){return t(),o("div",null,e[0]||(e[0]=[n('<h1 id="repetitions" tabindex="-1">Repetitions <a class="header-anchor" href="#repetitions" aria-label="Permalink to &quot;Repetitions&quot;">â€‹</a></h1><p>To memorize pice of information you can use spaced repetition algorithm.</p><p>There are 2 types repetition algorithms:</p><ul><li>que based - useful for words that are not memorized yet</li><li>schedule based - better if you now memorized something but will forget in future</li></ul><p>In <code>queue based</code> algorithm you&#39;re just moving index of selected question in queue of questions, so you can repeat the same question many times during single learning session. It is useful for new knowledge.</p><p>In <code>schedule based</code> you relay on time interval that decide which questions should be added to next learning session.</p><p>We are using both in the following way:</p><ol><li>When you see new word / respond incorrectly / ask for hint</li><li>Then <code>queue based</code> approach is used. Word will be queued in distances: <ul><li>2</li><li>4</li><li>8</li><li>16</li><li>32</li></ul></li><li>If you still can respond correctly to selected question after 32 other questions, it means that we con move to <code>schedule based</code> repetition.</li><li>In this case we&#39;re computing <code>final correctness</code> as lowest of <code>correctness</code> of all previous answers during this session.</li><li>When <code>correctnes</code> of single answer is:</li></ol><ul><li>0 - if answer do not belong to possible translations (trimmed, case-insensitive)</li><li>(1 - <code>hintLevel</code>) * (1 / (1 + 0.01 * (<code>timeTakenMs</code>/1000)**0.8)) - if answer is correct</li></ul><p>Hint level can be:</p><ul><li>0 - no hint</li><li>0.25 - only sentence was revealed</li><li>0.5 - sentence and image</li><li>1 - image sentence and translated sentence displayed</li></ul><p>I correctness we&#39;re taking into account time taken to answer but its impact is usually small.</p><p>Using one minute to figure out answer you will lose only 20% of correctness.</p><p><img src="'+s+`" alt="time_correctness_coefficient.png"></p><p>But thanks to this we can distingues between super easy and just easy words for you.</p><p>Originally FSRS is adjusted to scale of correctness:</p><pre><code>1 : again
2 : hard
3 : good
4 : easy
</code></pre><p>While our app using <code>0-1</code> scale so we just mapping it using linear function. We are using version <code>FSRS-5</code> describe in links:</p><ul><li><a href="https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm" target="_blank" rel="noreferrer">The Algorithm</a></li><li><a href="https://github.com/open-spaced-repetition/fsrs4anki/wiki/Awesome-FSRS" target="_blank" rel="noreferrer">Awesome FSRS</a></li></ul><p>This model uses <code>Three Component Model of Memory</code> called <code>DSR</code>:</p><ul><li>Difficulty (D): The inherent complexity of particular information.</li><li>Stability (S): The time, in days, required for R to decrease from 100% to 90%.</li><li>Retrievability (R): The probability that the person can successfully recall a particular piece of information at a given moment.</li></ul><p>You can read more about this model in <a href="https://github.com/open-spaced-repetition/fsrs4anki/wiki/ABC-of-FSRS" target="_blank" rel="noreferrer">ABC-of-FSRS</a>.</p>`,22)]))}const h=i(r,[["render",a]]);export{f as __pageData,h as default};
